<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter19.JavaScriptをより深く知る</title>

  <link rel="stylesheet" href="/sample/samples/common/css/style.css">
  <!-- <link rel="stylesheet" href="/sample/samples/c18/267/style.css"> -->

  <style>
  </style>
</head>
<body>
  <!-- <script type="module" src="./chapter19/269/main.js" defer></script> -->

  <div id="log"></div>


  <script>

    /*** 268.JavaScriptの読み込みタイミングを最適化したい
    **********************************************/
    // 利用シーン: JavaScriptの読み込み待ちでページの表示を妨げたくないとき
    //           素早くウェブページを表示させたいとき
    // 【構文①】
    // 構文 ： {}
    // 意味 ： ブロックスコープ


    /*** 269.処理ごとにファイルを分割したい（ESモジュール）
    **********************************************/
    // 利用シーン: 処理ごとにファイルを分割したいとき
    // 【構文①】
    // 構文 ： {}
    // 意味 ： ブロックスコープ


    /*** 270.モジュールをエクスポートしたい（export）
    **********************************************/
    // 利用シーン: 定数、関数などをモジュールとしてエクスポートしたいとき
    // 【構文①】
    // 構文 ： export モジュール
    // 意味 ： モジュールを公開する

    /***
    export const myConstant = 2;
    export const myObject = { name: '鈴木', age: 18 };
    export function myFunction() {
      console.log('my task');
    }
    export class MyClass {
      constructor() {}
    }
    ***/


    /*** 271.モジュールをインポートしたい（import）
    **********************************************/
    // 利用シーン: モジュールを取り込みたいとき
    //           サーバー上のモジュールをURLを指定して取り込みたいとき
    // 【構文①】
    // 構文 ： import { モジュール名 } from './ファイル.js'
    // 意味 ： モジュールを取り込む


    /*** 272.モジュールを用いたいJavaScriptをHTMLで読み込みたい
    **********************************************/
    // 利用シーン: モジュール型のJavaScriptを扱いたい
    // 【構文①】
    // 構文 ： <script type="module" src="ファイル名"><script>
    // 意味 ： ESモジュールを使ったJavaScriptの読み込み


    /*** 273.反復処理のためのイテレータを使いたい
    **********************************************/
    // 利用シーン: 反復処理が可能なオブジェクトを扱いたいとき
    // 【構文①】
    // メソッド ： オブジェクト[Symbol.iterator]()
    // 意味 ： イテレータを取得する
    // 戻り値 ： イテレータ
    // 【構文②】
    // メソッド ： イテレータ.next()
    // 意味 ： 次のイテレータを取得する
    // 戻り値 ： イテレータ
    // 【構文③】
    // プロパティ ： イテレータ.value
    // 意味 ： 現在の値
    // 型 ： 任意
    // 【構文④】
    // プロパティ ： イテレータ.done
    // 意味 ： 終了したかどうか
    // 型 ： 真偽値

    /***
    const array = [1,2,3];
    for(let value of array) {
      console.log(value);
    }

    const array = ['鈴木', '高橋', '田中'];

    const iterator = array[Symbol.iterator]();

    const next1 = iterator.next();
    console.log(next1);

    const next2 = iterator.next();
    console.log(next2);

    const next3 = iterator.next();
    console.log(next3);

    const next4 = iterator.next();
    console.log(next4);
    ***/


    /*** 274.イテレータを自作したい（ジェネレータ）
    **********************************************/
    // 利用シーン: オリジナルのイテレータを定義したいとき
    // 【構文①】
    // 構文 ： function* 関数名(){}
    // 意味 ： ジェネレータを定義する
    // 【構文②】
    // 構文 ： yield 値
    // 意味 ： 値を返す

    /***
    function* myGenerator() {
      yield '鈴木';
      yield '田中';
      yield '後藤';
    }

    const myIterable = myGenerator();

    console.log(myIterable.next());
    console.log(myIterable.next());
    console.log(myIterable.next());
    console.log(myIterable.next());

    for (let value of myIterable) {
      console.log(value);
    }

    function* range(start, end) {
      let result = start;
      while(result <= end) {
        yield result;
        result ++;
      }
    }

    for(let value of range(2,6)) {
      console.log(value);
    }
    ***/


    /*** 275.自分自身のみと等しくなるデータを扱いたい（Symbol）
    **********************************************/
    // 利用シーン: 絶対に重複しないデータを扱いたいとき
    //           ビルトインオブジェクトに独自メソッドを追加する場合のメソッド名を作成したいとき
    // 【構文①】
    // メソッド ： Symbol(文字列または数値)
    // 意味 ： シンボルを作成する
    // 戻り値 ： シンボル

    /***
    const symbol1 = Symbol();
    const symbol2 = Symbol();
    console.log(symbol1 == symbol2);
    console.log(symbol1 === symbol2);
    console.log(typeof symbol1);

    const symbol1 = Symbol();
    const symbol2 = Symbol();
    const symbol3 = Symbol('高橋');
    const symbol4 = Symbol(41);
    const symbol5 = Symbol('高橋');

    console.log(symbol1);
    console.log(symbol2);
    console.log(symbol3);
    console.log(symbol4);
    console.log(symbol5);
    console.log(symbol3 ===symbol5);
    ***/


    /*** 276.配列やオブジェクトに独自メソッドを追加したい
    **********************************************/
    // 利用シーン: 配列にシャッフル関数を追加したいとき
    //           オブジェクトにJSON変換メソッドを追加したいとき
    // 【構文①】
    // 構文 ： オブジェクト.prototype[シンボル] = function () {}
    // 意味 ： オブジェクトに独自メソッドを追加する
    // 【構文②】
    // 構文 ： オブジェクト.[シンボル]()
    // 意味 ： 独自メソッドを実行する

    // prototype
    // オブジェクト（Object）にメンバー（メンバー変数・メンバー関数）を追加するためのプロパティ。

    /***
    const myMethod = Symbol();
    Array.prototype[myMethod] = function() {
      console.log('独自のメソッドです');
    }

    const array = [1,2,3];
    array[myMethod]();

    // shuffle という名前の Symbol
    const shuffle = Symbol();

    // 配列のシャッフル関数を追加
    Array.prototype[shuffle] = function() {
      // シャッフル処理
      const arrayLength = this.length;
      for(let i=arrayLength-1; i>=0; i--) {
        const randomIndex = Math.floor(Math.random() * (i+1));
        [this[i], this[randomIndex]] = [this[randomIndex], this[i]];
      }

      return this;
    }

    // シャッフル関数のテスト
    // 配列の各数値を偶数を抜き出し、シャッフルして100倍する
    const array = [1,2,3,4,5,6,7,8,9,10];

    array
      .filter((value) => value%2 === 0)
      [shuffle]()
      .map((value) => value*100);

    console.dir(String.prototype);
    console.dir(Array.prototype);
    console.dir(Date.prototype);
    ***/


    /*** 277.キーと値のコレクション「Map」を使いたい
    **********************************************/
    // 利用シーン: キーと値を組み合わせて扱いたいとき
    //           連想配列を扱いたいとき

    /***
    const memberList = new Map();

    memberList.set(20,'鈴木');
    memberList.set(50,'田中');
    memberList.set(120,'高橋');

    const keyList = memberList.keys();
    for (let key of keyList) {
      console.log(key);
    }

    const valueList = memberList.values();
    for (value of valueList) {
      console.log(value);
    }

    const entryList = memberList.entries();
    for(let entry of entryList) {
      console.log(entry);
    }

    memberList.forEach((value,key) => {
      console.log(value,key);
    })
    ***/


    /*** 278.重複しない値のコレクションのための「Set」を使いたい
    **********************************************/
    // 利用シーン: 必ず一意になるユーザーIDの配列を取り扱いたいとき
    //           配列のように複数の値を扱うが、重複したものは除外したいとき

    const userIdList = new Set();

    userIdList.add(20);
    userIdList.add(50);
    userIdList.add(120);

    const valueList = userIdList.values();
    for(value of valueList) {
      console.log(value);
    }

    userIdList.forEach((value) => {
      console.log(value);
    })

    console.log([...userIdList]);
    console.log(userIdList);



  </script>
</body>
</html>
